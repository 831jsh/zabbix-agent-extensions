#!/usr/bin/env python3

# Marc Schoechlin <ms@256bit.org>
# Marc Schoechlin <Marc.Schoechlin@globalways.net>

import glob
import re
import os
import json
import sys
import argparse
import configparser

####################################################################################

regex_includes = [".*"]
regex_excludes = ["loop.*"]

####################################################################################
#### HELPERS


def check_match(matchfor, device_name, regexes):
  ret = False
  for regex in regexes:
    regex = regex.strip()
    if re.match(r"^%s$" % regex, device_name):
      if args.debug:
      	sys.stderr.write("%s match: %s with %s\n" % (matchfor, device_name, regex))
      ret = True
  return ret


# module "configparser" seems not to support sectionless inifiles
def read_config(config_files, regex_includes, regex_excludes):
  for config_file in config_files:
   if os.path.exists(config_file):
       if args.debug:
         sys.stderr.write("reading config file %s\n" % config_file)
       with open(config_file, 'r') as f:     
         config_string = '[global]\n' + f.read() 
         config = configparser.ConfigParser() 
         config.read_string(config_string)
         re_c = re.compile(r',')
         if "regex_includes" in config["global"]:
            regex_includes = re_c.split(config["global"]["regex_includes"])
         if "regex_excludes" in config["global"]:
            regex_excludes = re_c.split(config["global"]["regex_excludes"])
   return (regex_includes,regex_excludes)

def is_real_hardware_device(device):
    if os.path.exists("/sys/block/%s/device/vendor" % device):
        return True
    else:
        return False

####################################################################################
#### MAIN


parser = argparse.ArgumentParser(
    description='perform device disovery for zabbix'
)
parser.add_argument(
    '--debug',
    help='Output debug information',
    action='store_true',
)

parser.add_argument(
    '--only_hardware',
    help='Output only hardware devices',
    action='store_true',
)


parser.add_argument(
   '--config',
   nargs='*',
   type=str,
   help='configuration file',
   default=None,
   required=False,
)

args = parser.parse_args()

devices_discovered = {'data': []}

# read the config
if args.config is not None:
  (regex_includes, regex_excludes) = read_config(args.config, regex_includes, regex_excludes)

# perform discovery
for filename in glob.glob('/sys/block/*'):
  if not os.path.islink(filename): 
    continue
  device_name = os.path.basename(filename)
  if args.debug:
    sys.stderr.write("** DEVICE %s\n" % device_name)

  # Check matched devices
  if not check_match("include", device_name, regex_includes):
    continue

  # Check excluded devices
  if check_match("exclude", device_name, regex_excludes):
    continue

  if args.only_hardware and not is_real_hardware_device(device_name):
    continue

  device = {}
  device['{#BLOCKDEVICE}'] = device_name
  devices_discovered['data'].append(device)



if args.debug:
  print(json.dumps(devices_discovered, sort_keys=True, indent=2))
else:
  print(json.dumps(devices_discovered, sort_keys=True))

# vim: ai et ts=2 shiftwidth=2 expandtab
